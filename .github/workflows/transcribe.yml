name: Smart Subtitles (Commit to Repo)

on:
  workflow_dispatch:
    inputs:
      url:
        description: "视频链接（B站/YouTube等）"
        required: true
        type: string
      langs:
        description: "优先字幕语言（逗号分隔/可正则）"
        required: false
        default: "zh-Hans,zh-Hant,en.*"
        type: string
      whisper_model:
        description: "Whisper模型：tiny/base/small/medium/large"
        required: false
        default: "small"
        type: string
      whisper_language:
        description: "Whisper识别语言（留空自动检测）"
        required: false
        default: ""
        type: string
      user_agent:
        description: "可选：浏览器UA"
        required: false
        default: ""
        type: string

permissions:
  contents: write  # 允许用 GITHUB_TOKEN push 回仓库 [web:28][web:31]

concurrency:
  group: smart-subtitles
  cancel-in-progress: false

jobs:
  smart_subs:
    runs-on: ubuntu-latest
    env:
      YTDLP_COOKIES_TXT: ${{ secrets.YTDLP_COOKIES_TXT }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true # 让后面的 git push 直接可用 [web:42]
          fetch-depth: 0

      - name: Setup Node.js (for yt-dlp JS challenges)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install ffmpeg
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
          which ffmpeg

      - name: Setup Python with pip cache
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: |
            requirements.txt

      - name: Install Python dependencies
        shell: bash
        run: |
          python -m pip install -U pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install -U yt-dlp openai-whisper

      - name: Cache Whisper models
        uses: actions/cache@v4
        with:
          path: ~/.cache/whisper
          key: whisper-models-${{ inputs.whisper_model }}
          restore-keys: |
            whisper-models-

      - name: Write cookies.txt (optional)
        if: ${{ env.YTDLP_COOKIES_TXT != '' }}
        shell: bash
        run: |
          printf '%s' "$YTDLP_COOKIES_TXT" | tr -d '\r' > cookies.txt

      - name: Prepare folders
        shell: bash
        run: |
          mkdir -p subs work

      - name: Detect subtitle availability (JSON)
        id: detect
        env:
          URL: ${{ inputs.url }}
          LANGS: ${{ inputs.langs }}
          UA: ${{ inputs.user_agent }}
        shell: bash
        run: |
          python - <<'PY'
          import json, os, re, subprocess

          url = os.environ["URL"].strip()
          langs = os.environ.get("LANGS","").strip()
          ua = os.environ.get("UA","").strip()
          patterns = [re.compile(x.strip()) for x in langs.split(",") if x.strip()]

          cmd = [
            "yt-dlp",
            "--js-runtimes", "node",
            "--remote-components", "ejs:github",
            "--skip-download",
            "--write-auto-subs",
            "-J",
            url,
          ]
          if os.path.exists("cookies.txt"):
            cmd += ["--cookies", "cookies.txt"]
          if ua:
            cmd += ["--user-agent", ua]

          info = json.loads(subprocess.check_output(cmd, text=True))
          subs = info.get("subtitles") or {}
          auto = info.get("automatic_captions") or {}
          keys = sorted(set(list(subs.keys()) + list(auto.keys())))

          def ok(k: str) -> bool:
            for r in patterns:
              if r.fullmatch(k) or r.search(k):
                return True
            return False

          matched = [k for k in keys if ok(k)]
          mode = "download" if matched else "whisper"

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
            f.write(f"mode={mode}\n")
            f.write("matched_langs=" + ",".join(matched) + "\n")

          print("mode =", mode)
          print("matched_langs =", ",".join(matched) if matched else "(none)")
          PY

      - name: Download existing subtitles (manual/auto)
        if: steps.detect.outputs.mode == 'download'
        env:
          URL: ${{ inputs.url }}
          LANGS: ${{ inputs.langs }}
          UA: ${{ inputs.user_agent }}
        shell: bash
        run: |
          set -euo pipefail
          UA_ARGS=()
          if [[ -n "${UA}" ]]; then UA_ARGS=(--user-agent "${UA}"); fi
          COOKIE_ARGS=()
          if [[ -f cookies.txt ]]; then COOKIE_ARGS=(--cookies cookies.txt); fi

          yt-dlp \
            --js-runtimes node --remote-components ejs:github \
            --skip-download \
            --write-subs --write-auto-subs \
            --sub-langs "${LANGS}" \
            --sub-format "vtt/best" \
            --convert-subs srt \
            -o "subs/%(title).200s_%(id)s.%(ext)s" \
            "${URL}" \
            "${COOKIE_ARGS[@]}" \
            "${UA_ARGS[@]}"

      - name: Decide if Whisper is needed (fallback)
        id: postcheck
        shell: bash
        run: |
          shopt -s nullglob
          files=(subs/*.srt subs/*.vtt subs/*.txt subs/*.lrc)
          if [[ "${{ steps.detect.outputs.mode }}" == "whisper" ]]; then
            echo "need_whisper=true" >> "$GITHUB_OUTPUT"
          elif (( ${#files[@]} == 0 )); then
            echo "need_whisper=true" >> "$GITHUB_OUTPUT"
          else
            echo "need_whisper=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Download audio for Whisper
        if: steps.postcheck.outputs.need_whisper == 'true'
        env:
          URL: ${{ inputs.url }}
          UA: ${{ inputs.user_agent }}
        shell: bash
        run: |
          set -euo pipefail
          UA_ARGS=()
          if [[ -n "${UA}" ]]; then UA_ARGS=(--user-agent "${UA}"); fi
          COOKIE_ARGS=()
          if [[ -f cookies.txt ]]; then COOKIE_ARGS=(--cookies cookies.txt); fi

          yt-dlp \
            --js-runtimes node --remote-components ejs:github \
            -f "bestaudio/best" \
            -o "work/%(title).200s_%(id)s.%(ext)s" \
            "${URL}" \
            "${COOKIE_ARGS[@]}" \
            "${UA_ARGS[@]}"

      - name: Whisper generate subtitles (SRT+TXT+VTT)
        if: steps.postcheck.outputs.need_whisper == 'true'
        env:
          MODEL: ${{ inputs.whisper_model }}
          WHISPER_LANG: ${{ inputs.whisper_language }}
        shell: bash
        run: |
          set -euo pipefail
          AUDIO_FILE="$(ls -1 work/* | head -n 1)"

          LANG_ARGS=()
          if [[ -n "${WHISPER_LANG}" ]]; then LANG_ARGS=(--language "${WHISPER_LANG}"); fi

          whisper "${AUDIO_FILE}" \
            --model "${MODEL}" \
            --output_dir "subs" \
            --output_format "all" \
            "${LANG_ARGS[@]}"

      - name: Convert SRT -> LRC (simple)
        if: steps.postcheck.outputs.need_whisper == 'true'
        shell: bash
        run: |
          python - <<'PY'
          import glob, os, re
          def srt_time_to_lrc(t):
            hh, mm, rest = t.split(":")
            ss, ms = rest.split(",")
            total_mm = int(hh)*60 + int(mm)
            xx = int(ms)//10
            return f"{total_mm:02d}:{int(ss):02d}.{xx:02d}"

          for srt in glob.glob("subs/*.srt"):
            with open(srt, "r", encoding="utf-8", errors="ignore") as f:
              lines = [x.rstrip("\n") for x in f]

            out = []
            i = 0
            while i < len(lines):
              if re.fullmatch(r"\d+", (lines[i].strip() or "")):
                i += 1
                if i < len(lines) and "-->" in lines[i]:
                  time_line = lines[i]
                  i += 1
                  text = []
                  while i < len(lines) and lines[i].strip() != "":
                    text.append(lines[i].strip())
                    i += 1
                  start = time_line.split("-->")[0].strip()
                  if text:
                    out.append(f"[{srt_time_to_lrc(start)}] " + " ".join(text))
              i += 1

            lrc = os.path.splitext(srt)[0] + ".lrc"
            with open(lrc, "w", encoding="utf-8") as f:
              f.write("\n".join(out).strip() + ("\n" if out else ""))

          print("generated:", glob.glob("subs/*.lrc"))
          PY

      - name: Commit & push subtitles (to current repo)
        env:
          URL: ${{ inputs.url }}
        shell: bash
        run: |
          set -euo pipefail

          # 只关心 subs/ 是否有变化
          if [[ -z "$(git status --porcelain subs)" ]]; then
            echo "No changes under subs/. Skip commit."
            exit 0
          fi

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add subs
          git commit -m "Add subtitles: ${URL}" || exit 0

          # 参考你另一个 workflow：直接 push（使用 checkout 持久化的凭据）
          git push
